# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    paging.c~                                          :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: vvaucoul <vvaucoul@student.42.Fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2022/08/16 15:46:16 by vvaucoul          #+#    #+#              #
#    Updated: 2022/11/20 14:02:41 by vvaucoul         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include <memory/paging.h>
#include <memory/frames.h>
#include <asm/asm.h>

#include <memory/kheap.h>

#include <system/pit.h>

PageDirectory *__kernel_page_directory __attribute__((aligned(PAGE_SIZE))) = NULL;
PageDirectory *__current_page_directory __attribute__((aligned(PAGE_SIZE))) = NULL;

bool __paging_enabled = false;

uint32_t *__kernel_page_memory = NULL;

/* TMP */

// unsigned int __tmp_page_directory[PAGE_DIRECTORY_SIZE] __attribute__((aligned(PAGE_SIZE))) = {0};
// unsigned int __tmp_page_table[PAGE_TABLE_SIZE] __attribute__((aligned(PAGE_SIZE))) = {0};

// static void __init_tmp_pages()
// {
//     memset(__tmp_page_directory, 0, PAGE_DIRECTORY_SIZE * sizeof(unsigned int));
//     memset(__tmp_page_table, 0, PAGE_TABLE_SIZE * sizeof(unsigned int));

//     for (uint32_t i = 0; i < PAGE_DIRECTORY_SIZE; i++)
//     {
//         __tmp_page_directory[i] = 0x00000002;
//     }

//     for (uint32_t i = 0; i < PAGE_TABLE_SIZE; i++)
//     {
//         __tmp_page_table[i] = (i * 0x1000) | 3;
//     }

//     __tmp_page_directory[0] = ((unsigned int)__tmp_page_table) | 0x03;

//     __load_page_directory(__tmp_page_directory);
//     __enable_paging();
//     // __enable_large_pages();
// }

// void identity_paging()
// {
// }

// void *__request_new_page(size_t size)
// {
//     __UNUSED(size);
// }

/* Convert Virtual to Physical Address */
__paging_data_t *virtual_to_phys(PageDirectory *dir, xvaddr_t *vaddr)
{
    if (__paging_enabled == false)
        return ((__paging_data_t *)vaddr - KERNEL_VIRTUAL_BASE);
    else
    {
        uint32_t page_directory_index = PAGE_DIRECTORY_INDEX(vaddr);
        uint32_t page_table_index = PAGE_TABLE_INDEX(vaddr);
        uint32_t page_frame_offset = PAGE_FRAME_INDEX(vaddr);

        assert(dir->tables[page_directory_index] == NULL);

        PageTable *table = dir->tables[page_directory_index];
        assert(table->pages[page_table_index].present);

        uint32_t frame = table->pages[page_table_index].frame;
        uint32_t phys = (frame << 12) + page_frame_offset;
        return ((__paging_data_t *)phys);
    }
}

__paging_data_t *kmalloc_paging(uint32_t size, bool align, void *phys)
{
    __paging_data_t *addr = __kernel_page_memory;

    if (phys != NULL)
        phys = (void *)addr;
    if (align && (IS_ALIGNED(addr) == false))
        addr = (void *)ALIGN_PAGE(addr);
    __kernel_page_memory += size;
    printk("Addr: 0x%x - Phys: 0x%x\n", addr, phys);
    return (addr);
}

void allocate_region(PageDirectory *dir, vaddr_t vaddr_start, vaddr_t vaddr_end, uint32_t hidden, bool is_kernel, bool is_writable)
{
    vaddr_t va_start = vaddr_start & VPAGE_MASK;
    vaddr_t va_end = vaddr_end & VPAGE_MASK;

    assert(va_start >= va_end);
    while (va_start <= va_end)
    {
        if (hidden == true)
            allocate_page(dir, va_start, va_start / PAGE_SIZE, is_kernel, is_writable);
        else
            allocate_page(dir, va_start, 0, is_kernel, is_writable);
        va_start += PAGE_SIZE;
    }
}

void allocate_page(PageDirectory *dir, vaddr_t vaddr, vaddr_t frame, bool is_kernel, bool is_writable)
{
    PageTable *table = NULL;

    assert(dir == NULL);
    uint32_t page_directory_index = PAGE_DIRECTORY_INDEX(vaddr);
    uint32_t page_table_index = PAGE_TABLE_INDEX(vaddr);

    table = dir->tables[page_directory_index];
    if (table == NULL)
    {
        // Check Heap enabled or not
        // if ()
        // {
        // }

        table = kmalloc_a(sizeof(PageTable));
        memset(table, 0, sizeof(PageTable));

        uint32_t table_phys = (uint32_t)virtual_to_phys(__kernel_page_directory, table);
        // dir->tables[page_directory_index]->pages.frame = table_phys >> 12;
        // dir->tables[page_directory_index]->pages.present = 1;
        // dir->tables[page_directory_index]->pages.rw = (is_writable) ? 1 : 0;
        // dir->tables[page_directory_index]->pages.user = (is_kernel) ? 0 : 1;
        // dir->tables[page_directory_index]->pages->pageSize =
    }
}

// Page *get_page(uint32_t addr, bool make, PageDirectory *dir)
// {
//     static uint32_t i = 0;

//     addr /= PAGE_SIZE;
//     uint32_t table_idx = addr / PAGE_TABLE_SIZE;
//     if (dir->tables[table_idx])
//     {
//         return (&dir->tables[table_idx]->pages[addr % PAGE_TABLE_SIZE]);
//     }
//     else if (make)
//     {
//         printk("Create Page index: %d\n", i);
//         uint32_t tmp;

//         // dir->tables[table_idx] = (PageTable *)kmalloc_ap(sizeof(PageTable), &tmp);
//         dir->tables[table_idx] = (PageTable *)kmalloc_paging(sizeof(PageTable), true, &tmp);
//         memset(dir->tables[table_idx], 0, sizeof(PageTable));
//         dir->tablesPhysical[table_idx] = tmp | PAGE_ATTRIBUTE_PRESENT | PAGE_ATTRIBUTE_READ_WRITE | PAGE_ATTRIBUTE_USER; // 0x7;
//         return (&dir->tables[table_idx]->pages[addr % PAGE_TABLE_SIZE]);
//     }
//     return (NULL);
// }

Page *create_page(uint32_t addr, PageDirectory *dir)
{
    uint32_t phys = 0;
    uint32_t table_idx = 0;

    addr /= PAGE_SIZE;
    table_idx = addr / PAGE_TABLE_SIZE;
    printk("Create Page index: %d\n", table_idx);
    dir->tables[table_idx] = (PageTable *)kmalloc_ap(sizeof(PageTable), &phys);
    printk("Test: 0x%x\n", phys);
    memset(dir->tables[table_idx], 0, sizeof(PageTable));
    dir->tablesPhysical[table_idx] = phys | PAGE_ATTRIBUTE_PRESENT | PAGE_ATTRIBUTE_READ_WRITE | PAGE_ATTRIBUTE_USER; // 0x7;
    return (&dir->tables[table_idx]->pages[addr % PAGE_TABLE_SIZE]);
}

Page *get_page(uint32_t addr, PageDirectory *dir)
{
    addr /= PAGE_SIZE;
    uint32_t table_idx = addr / PAGE_TABLE_SIZE;
    if (dir->tables[table_idx])
    {
        return (&dir->tables[table_idx]->pages[addr % PAGE_TABLE_SIZE]);
    }
    return (NULL);
}

static void inline_enable_paging()
{
    uint32_t cr0;
    uint32_t cr4;

    asm volatile("mov %%cr4, %0"
                 : "=r"(cr4));
    CLEAR_PSEBIT(cr4);
    asm volatile("mov %0, %%cr4" ::"r"(cr4));

    asm volatile("mov %%cr0, %0"
                 : "=r"(cr0));
    SET_PGBIT(cr0);
    asm volatile("mov %0, %%cr0" ::"r"(cr0));

    __paging_enabled = true;
}

static void switch_page_directory(PageDirectory *dir)
{
    // __current_page_directory = dir;
    // __load_page_directory(&dir->tablesPhysical);

    uint32_t cr0 = 0;
    uint32_t cr4 = 0;

    __current_page_directory = dir;
    CLEAR_PSEBIT(cr4);
    asm volatile("mov %0, %%cr3" ::"r"(&dir->tablesPhysical));
    asm volatile("mov %%cr0, %0"
                 : "=r"(cr0));
}

static void __init()
{
    uint32_t end_page_addr = PHYSICAL_MEMORY_SIZE;

    init_frames();
    kpause();
}

static void __init_paging(void)
{
    __init();
    return;

    // __init_tmp_pages();
    // isr_register_interrupt_handler(14, __page_fault);
    // __paging_enabled = true;
    // return;

    // TO DO

    // __enable_paging();

    /*

        memset(__page_directory.pages, 0, sizeof(Page) * PAGE_DIRECTORY_SIZE);
        memset(__page_table.pages, 0, sizeof(Page) * PAGE_TABLE_SIZE);

        // set all page directory read/write & user access
        for (uint32_t i = 0; i < PAGE_DIRECTORY_SIZE; i++)
        {
            __page_directory.pages[i].rw = 1;
            __page_directory.pages[i].user = 1;
        }

        // Enable 4MB pages
        for (uint32_t i = 0; i < PAGE_TABLE_SIZE; i++)
        {
            __page_table.pages[i].present = 1;
            __page_table.pages[i].rw = 1;
            __page_table.pages[i].user = 1;
            __page_table.pages[i].frame = (i * PAGE_SIZE) >> 12;
        }

        // set first page directory to be accessed with frame 0x11a(kernel region address)
        // __page_directory.pages[0].present = 1;
        // __page_directory.pages[0].accessed = 0;
        // __page_directory.pages[0].user = 1;
        // __page_directory.pages[0].frame = 0x11A;

        //__page_directory.pages[0] = __page_table.pages[0];

        __page_directory.pages[0].present = 1;
        __page_directory.pages[0].rw = 1;
        __page_directory.pages[0].user = 1;
        __page_directory.pages[0].frame = ((uint32_t)__page_table.pages) >> 12;

        isr_register_interrupt_handler(14, __page_fault);

        // set cr3 point to page directory
        // asm volatile("mov %0, %%cr3" ::"r"(&__page_directory.pages));

        // // set bit in cr0 to enable paging
        // asm volatile("mov %%cr0, %0"
        //              : "=r"(cr0));
        // cr0 = cr0 | 0x80000000;
        // asm volatile("mov %0, %%cr0" ::"r"(cr0));

        // set cr3 to page directory address
        __load_page_directory((__page_directory.pages));
        // set cr0 to paging enabled
        __enable_paging();
        // enable 4MB pages
        // __enable_large_pages();
        kpause();
        __paging_enabled = true;
    */
}

void init_paging(void)
{
    __init_paging();
}

static void __generate_page_fault_panic(char buffer[PAGE_FAULT_BUFFER_SIZE], struct regs *r)
{
    uint32_t faulting_address;

    PAGE_FAULT_ADDR(faulting_address); // Get the faulting address

    int present = !(r->err_code & 0x1); // Page not present
    int rw = r->err_code & 0x2;         // Write operation?
    int us = r->err_code & 0x4;         // Processor was in user-mode?

    // 0 - 0 - 0
    if (us == false && rw == false && present == false)
        memjoin(buffer, PAGE_FAULT_PANIC_000, 0, strlen(PAGE_FAULT_PANIC_000));
    // 0 - 0 - 1
    else if (us == false && rw == false && present == true)
        memjoin(buffer, PAGE_FAULT_PANIC_001, 0, strlen(PAGE_FAULT_PANIC_001));
    // 0 - 1 - 0
    else if (us == false && rw == true && present == false)
        memjoin(buffer, PAGE_FAULT_PANIC_010, 0, strlen(PAGE_FAULT_PANIC_010));
    // 0 - 1 - 1
    else if (us == false && rw == true && present == true)
        memjoin(buffer, PAGE_FAULT_PANIC_011, 0, strlen(PAGE_FAULT_PANIC_011));
    // 1 - 0 - 0
    else if (us == true && rw == false && present == false)
        memjoin(buffer, PAGE_FAULT_PANIC_100, 0, strlen(PAGE_FAULT_PANIC_100));
    // 1 - 0 - 1
    else if (us == true && rw == false && present == true)
        memjoin(buffer, PAGE_FAULT_PANIC_101, 0, strlen(PAGE_FAULT_PANIC_101));
    // 1 - 1 - 0
    else if (us == true && rw == true && present == false)
        memjoin(buffer, PAGE_FAULT_PANIC_110, 0, strlen(PAGE_FAULT_PANIC_110));
    // 1 - 1 - 1
    else if (us == true && rw == true && present == true)
        memjoin(buffer, PAGE_FAULT_PANIC_111, 0, strlen(PAGE_FAULT_PANIC_111));
    else
        memjoin(buffer, PAGE_FAULT_PANIC_UNKNOWN, 0, strlen(PAGE_FAULT_PANIC_UNKNOWN));

    memjoin(buffer, "\n\tError: ", strlen(buffer), 9);
    if (us == false && rw == false && present == false)
        memjoin(buffer, "0 - 0 - 0", strlen(buffer), 9);
    else if (us == false && rw == false && present == true)
        memjoin(buffer, "0 - 0 - 1", strlen(buffer), 9);
    else if (us == false && rw == true && present == false)
        memjoin(buffer, "0 - 1 - 0", strlen(buffer), 9);
    else if (us == false && rw == true && present == true)
        memjoin(buffer, "0 - 1 - 1", strlen(buffer), 9);
    else if (us == true && rw == false && present == false)
        memjoin(buffer, "1 - 0 - 0", strlen(buffer), 9);
    else if (us == true && rw == false && present == true)
        memjoin(buffer, "1 - 0 - 1", strlen(buffer), 9);
    else if (us == true && rw == true && present == false)
        memjoin(buffer, "1 - 1 - 0", strlen(buffer), 9);
    else if (us == true && rw == true && present == true)
        memjoin(buffer, "1 - 1 - 1", strlen(buffer), 9);
    else
        memjoin(buffer, "Unknown error", strlen(buffer), 13);

    memjoin(buffer, "\n\tFaulting address: 0x", strlen(buffer), 22);

    char __kitoa_buffer[__KITOA_BUFFER_LENGTH__];
    bzero(__kitoa_buffer, __KITOA_BUFFER_LENGTH__);
    kuitoa_base(faulting_address, 16, __kitoa_buffer);
    memjoin(buffer, __kitoa_buffer, strlen(buffer), strlen(__kitoa_buffer));
    memjoin(buffer, "\n", strlen(buffer), 1);
    printk("Addr error: 0x%x\n", faulting_address);
}

void __page_fault(struct regs *r)
{
    /*
    ** US RW  P - Description
    ** 0  0  0 - Supervisory process tried to read a non-present page entry
    ** 0  0  1 - Supervisory process tried to read a page and caused a protection fault
    ** 0  1  0 - Supervisory process tried to write to a non-present page entry
    ** 0  1  1 - Supervisory process tried to write a page and caused a protection fault
    ** 1  0  0 - User process tried to read a non-present page entry
    ** 1  0  1 - User process tried to read a page and caused a protection fault
    ** 1  1  0 - User process tried to write to a non-present page entry
    ** 1  1  1 - User process tried to write a page and caused a protection fault
    */

    char buffer[PAGE_FAULT_BUFFER_SIZE];

    bzero(buffer, PAGE_FAULT_BUFFER_SIZE);
    __generate_page_fault_panic(buffer, r);
    __PANIC(buffer);
}